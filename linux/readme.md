# linux 内存管理

每个项目的物理地址对于进程不可见，谁也不能直接访问这个物理地址。操作系统会给进程分配一个虚拟地址。所有进程看到的这个地址都是一样的，里面的内存都是从 0 开始编号。  
内存中的地址可分为 ： 
  逻辑地址：逻辑地址是由段和段偏移量组成。  
  线性地址：线性地址也称为虚拟地址，由十六进制表示，经过分页单元转化为物理之地。  
  物理地址：真是的物理地址。 
虚拟空间，一部分用来放内核的东西，称为内核空间，一部分用来放进程的东西，称为用户空间，低地址是用户态信息，高地址是内核信息。
## 逻辑地址映射到线性地址
![image](https://github.com/yanlongLv/notes/blob/main/linux/duan1.jpg)   
逻辑地址由两部分组成，段标识符合和段内地址偏移量。 
分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。  

## 线性地址到物理地址的映射    

从虚拟地址到物理地址的转换方式，称为分页（Paging）。  
![image](https://github.com/yanlongLv/notes/blob/main/linux/xuni1.jpg)  
虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。  
![image](https://github.com/yanlongLv/notes/blob/main/linux/yishe.jpg)  
我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K。  
页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，用 12 位可以定位这个页内的任何一个位置。  
![image](https://github.com/yanlongLv/notes/blob/main/linux/page.jpg)  
如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，最多 4K，这样内存就节省多了。  